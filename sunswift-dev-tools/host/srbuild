#!/usr/bin/env python3

###############################################################################
# Sunswift High Level build tool
# Version: V1.0
# Date: 7/01/2026
# Author: Ryan Wong
#
# Wrapper around CMake to allow you to intuitevly build all, one, or some targets
# Also features a "make clean" command
# ONLY allowed to be used within the SRP8-130 high level embedded repository
# 
# Usage:
#   - srbuild --all
#   - srbuild --target/-t node1 node2 lib1...
#   - srbuild --clean
###############################################################################

import argparse
import sys
import subprocess
import time
import shutil
from typing import Optional
from pathlib import Path

CWD = Path.cwd()
# THIS ASSUMES that repo root is 2 directories above this script...
REPO_ROOT = Path(__file__).resolve().parents[2]
if not (REPO_ROOT/"src").exists() and not (REPO_ROOT/"core").exists():
    print(f"Error: {__file__} not 2 below repo root")

# =================================================================================================
# HELPERS
# =================================================================================================

def die(msg: str) -> None:
    """Kills script and prints out msg"""
    print(msg)
    sys.exit(1)

def safe_rmdir(path: Path) -> bool:
    """Absolutely every error check again just to confirm before deletion. 
    In case any bugs in error checking happen before. Then deletes specified dir
    Args:
        path (Path): path of dir to be deleted
    """
    if not path.exists():
        print("Clean: Path does not exist")
        return False
        
    if not path.is_dir():
        print("Clean: Path is not a directory")
        return False
        
    if path.is_symlink():
        print("Clean: Path is a symlink")
        return False

    try:
        # Check if path is within repository 
        path.relative_to(REPO_ROOT)
    except ValueError:
        print("Path not within SRP8-130_EMBD_High_Level repository")
        return False
    
    if path == REPO_ROOT or path == "/" or path == REPO_ROOT / "src" or path == REPO_ROOT / "core":
        die("wtf are u doing man")

    shutil.rmtree(path)
    return True


# =================================================================================================
# CORE LOGIC
# =================================================================================================

def build(targets: Optional[list[str]], all: bool, cores: int) -> None:
    """Creates root /build if it doesn't exist. Then builds passed in targets, 
    OR builds all targets using "cores" number of jobs

    Args:
        targets (Optional[list[str]]): list of target names to build
        all (bool): whether to build all or not
        cores (int): number of jobs to run in parallel
    """
    # Always Initialise CMake in /build
    build_dir_path = REPO_ROOT/"build"
    cmakelists_path = REPO_ROOT/"CMakeLists.txt"
    num_cores = f"-j{cores}"
    
    print("============ CMake Initialisation ============")
    # CMakeLists.txt at root MUST exist. Makes build dir if does not exist
    if not (cmakelists_path.exists() and cmakelists_path.is_file()):
        die("Build: Root CMakeLists.txt does not exist")
    if not (build_dir_path.exists() and build_dir_path.is_dir()):
        print("Build: root build directory not found, creating build/")
        build_dir_path.mkdir()

    start_time = time.time()
    # Re-init cmake
    try:
        print("Build: Initialising CMake")
        subprocess.run([
            "cmake", "-S", str(REPO_ROOT), "-B", str(build_dir_path),
        ], check=True)
    except subprocess.CalledProcessError as e:
        die(f"Build: Error initialising CMake: {e}")

    print("============= Building Targets ===============")
    # Build targets
    try:
        if all:
            print("Build: Building all targets")
            subprocess.run([
                "cmake", "--build", str(build_dir_path), "--", num_cores
            ], check=True)
        elif targets is not None:
            print("Build: Building specified targets")
            # Uhh loop is probably less efficient, but the alternative is messy
            # If someone is using --target, build times probably tiny anyway
            for target in targets:
                subprocess.run([
                    "cmake", "--build", str(build_dir_path), "--target", target, "--", num_cores
                ], check=True)
    except subprocess.CalledProcessError:
        die(f"Build: Error building targets")
    print("=============== Build Complete =================")
    end_time = time.time()
    print(f"Build finished in {end_time-start_time:.4f} seconds")


def clean() -> None:
    """Deletes deploy/, build/, and lib/ from repo root."""
    print("============= Cleaning Targets ===============")
    res = input("Would you like to remove /deploy /lib and /build from repository root? (y/n): ")
    if res.lower() != "y":
        die("Cancelling clean..")

    for dir_name in ["build", "lib", "deploy"]:
        dir_path = REPO_ROOT / dir_name
        if dir_path.exists():
            print(f"Clean: Removing {dir_name} directory: {dir_path}")
            ret = safe_rmdir(dir_path)
            if ret: print(f"Clean: {dir_name} removed successfully.")
        else:
            print(f"Clean: {dir_name} does not exist, skipping.")

    print("============== Clean Complete ================")


# =================================================================================================
# MAIN
# =================================================================================================

"""
NEW CLI
srbuild all 
srbuild node node1, node2, node3
srbuild clean -> this should delete build/ NOT deploy
if no --build and --install flags, automatically does both
"""
def main():
    ### Parse command line args
    parser = argparse.ArgumentParser(
        description="Sunswift build and staging tool"
    )

    common_flags = argparse.ArgumentParser(add_help=False)
    common_flags.add_argument("--build", "-b", action="store_true", help="Only build the targets, do not install")
    common_flags.add_argument("--install", "-i", action="store_true", help="Installs already built targets, fails if not built")
    
    level1_junction = parser.add_subparsers(dest="command", required=True)
    command_all = level1_junction.add_parser("all", parents=[common_flags], help="Build and install all targets")
    command_clean = level1_junction.add_parser("clean", help="Delete the build directory, but NOT deploy/")
    command_node = level1_junction.add_parser("node", parents=[common_flags], help="Select specific nodes to build and install")
    command_node.add_argument("targets", nargs="+", help="One or more node target names")
    args = parser.parse_args() 
        
    ### SANITY CHECK - immediately fail if not used within SRP8-130 High level embedded repository
    try:
        CWD.relative_to(REPO_ROOT)
    except ValueError:
        die("Error: Script must be run within repository")
    
    ### Handle option
    # if args.target or args.all:
    #     build(args.target, args.all, args.jobs)
    # elif args.clean:
    #     clean()
    if args.command == "all":
        # if just -i then only install
        # if just -b then only build
        # else build and install all
        pass
    elif args.command == "clean":
        # delete build/
        pass
    elif args.command == "node":
        # take in args.targets, build and install all
        print(args.install)
        print(args.build)

if __name__ == "__main__":
    main()
    
