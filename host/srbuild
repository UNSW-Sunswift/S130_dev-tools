#!/usr/bin/env python3

###############################################################################
# Sunswift High Level build tool
# Version: V2.0
# Date: 7/01/2026
# Author: Ryan Wong
#
# Wrapper around CMake to allow you to intuitevly build and install all, one, or some targets
# 
# 
# Usage:
#   - srbuild all
#   - srbuild target node1 node2 ...
#   - srbuild clean
###############################################################################

import argparse
import os
import sys
import subprocess
import time
import shutil
from typing import Optional
from pathlib import Path

CWD = Path.cwd().resolve()
REPO_ROOT = Path()
BUILD_DIR_PATH = Path()
CMAKELISTS_PATH = Path()
INSTALL_PREFIX = Path()
MARKER_FILE = ".sunswift-evsn"

# =================================================================================================
# HELPERS
# =================================================================================================

def die(msg: str) -> None:
    """Kills script and prints out msg"""
    print(msg)
    sys.exit(1)

def git_toplevel(path: Path) -> Path:
    try:
        result = subprocess.run(
            ["git", "-C", str(path), "rev-parse", "--show-toplevel"],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
    except FileNotFoundError:
        die("Error: git not found; cannot determine repository root")
    except subprocess.CalledProcessError:
        die("Error: not a git repository (or any of the parent directories)")
    root = result.stdout.strip()
    if not root:
        die("Error: git returned empty repository root")
    return Path(root).resolve()

def resolve_repo_root(cli_root: Optional[str]) -> Path:
    env_root = os.environ.get("SR_REPO_ROOT")
    if cli_root:
        candidate = Path(cli_root).expanduser().resolve()
    elif env_root:
        candidate = Path(env_root).expanduser().resolve()
    else:
        return git_toplevel(CWD)

    if not candidate.exists() or not candidate.is_dir():
        die("Error: repo root does not exist or is not a directory")
    git_root = git_toplevel(candidate)
    if git_root != candidate:
        die("Error: repo root is not a git repository root")
    return candidate

def validate_repo_root(repo_root: Path) -> None:
    if not (repo_root / "src").exists() and not (repo_root / "core").exists():
        die("Error: repository root missing src/ or core/")
    if not (repo_root / MARKER_FILE).exists():
        die(f"Error: marker file '{MARKER_FILE}' not found in repository root")
    
def safe_rmdir(path: Path) -> bool:
    """Absolutely every error check again just to confirm before deletion. 
    In case any bugs in error checking happen before. Then deletes specified dir
    Args:
        path (Path): path of dir to be deleted
    """
    if not path.exists():
        print("Clean: Path does not exist")
        return False
        
    if not path.is_dir():
        print("Clean: Path is not a directory")
        return False
        
    if path.is_symlink():
        print("Clean: Path is a symlink")
        return False

    try:
        # Check if path is within repository 
        path.relative_to(REPO_ROOT)
    except ValueError:
        print("Path not within SRP8-130_EMBD_High_Level repository")
        return False
    
    if path == REPO_ROOT or path == "/" or path == REPO_ROOT / "src" or path == REPO_ROOT / "core":
        die("wtf are u doing man")

    shutil.rmtree(path)
    return True


# =================================================================================================
# CORE LOGIC
# =================================================================================================

def configure_cmake() -> None:
    """
    Creates BUILD_DIR_PATH if doesn't exist, configures cmake using CMAKELISTS_PATH.
    Specifies install prefix as INSTALL_PREFIX    
    """

    print("============ CMake Initialisation ============")
    # CMakeLists.txt at root MUST exist. Makes build dir if does not exist
    if not (CMAKELISTS_PATH.exists() and CMAKELISTS_PATH.is_file()):
        die("Build: Root CMakeLists.txt does not exist")
    if not (BUILD_DIR_PATH.exists() and BUILD_DIR_PATH.is_dir()):
        print("Build: Root build directory not found, creating build/")
        try:
            BUILD_DIR_PATH.mkdir()
        except Exception as e:
            die(f"Error: Failed to create build directory: {e}")

    # Re-init cmake
    try:
        print("Build: Initialising CMake")
        subprocess.run([
            "cmake", "-S", str(REPO_ROOT), "-B", str(BUILD_DIR_PATH), f"-DCMAKE_INSTALL_PREFIX={INSTALL_PREFIX}"
        ], check=True)
    except subprocess.CalledProcessError as e:
        die(f"Build: Error configuring CMake: {e}")


def build(targets: Optional[list[str]], jobs: int) -> None:
    """Builds one, many or all nodes using number of jobs. Does not install

    Args:
        targets (Optional[list[str]]): list of target names to build, if None, do all
        jobs (int): number of jobs to run in parallel
    """
    print("============= Building Targets ===============")
    jobs_str = f"-j{jobs}"
    start_time = time.time()
    # Build targets
    try:
        if targets is None:
            print("Build: Building all targets")
            subprocess.run([
                "cmake", "--build", str(BUILD_DIR_PATH), "-j", jobs_str
            ], check=True)
        else:
            print("Build: Building specified targets")
            # Uhh loop is probably less efficient, but the alternative is messy
            # If someone is using --target, build times probably tiny anyway
            for target in targets:
                subprocess.run([
                    "cmake", "--build", str(BUILD_DIR_PATH), "--target", target, "--", jobs_str
                ], check=True)
    except subprocess.CalledProcessError:
        die(f"Build: Error building targets")
    
    print("=============== Build Complete =================")
    end_time = time.time()
    print(f"Build finished in {end_time-start_time:.4f} seconds")

def install(targets: Optional[list[str]]) -> None:
    print("============= Installing Targets ===============")
    start_time = time.time()
    # Install targets
    try:
        if targets is None:
            print("Install: Installing all targets")
            subprocess.run([
                "cmake", "--install", str(BUILD_DIR_PATH)
            ], check=True)
        else:
            print("Install: Installing specified targets")
            for target in targets:
                subprocess.run([
                    "cmake", "--install", str(BUILD_DIR_PATH), "--component", target
                ], check=True)

        # No matter what, always install runtime tools
        subprocess.run([
            "cmake", "--install", str(BUILD_DIR_PATH), "--component", "tools"
        ], check=True)
    except subprocess.CalledProcessError:
        die(f"Build: Error building targets")

    
    print("=============== Install Complete =================")
    end_time = time.time()
    print(f"Install finished in {end_time-start_time:.4f} seconds")

def clean() -> None:
    """Deletes build/ from repo root."""
    print("============= Cleaning Targets ===============")
    res = input("Would you like to remove /build from repository root? (y/n): ")
    if res.lower() != "y":
        die("Cancelling clean..")

    build_path = REPO_ROOT / "build"
    if build_path.exists() and build_path.is_dir():
        print(f"Clean: Removing 'build' directory")
        ret = safe_rmdir(build_path)
        if ret: print(f"Clean: 'build' removed successfully.")
    else:
        print(f"Clean: {build_path} does not exist")

    print("============== Clean Complete ================")

def build_all(jobs: int) -> None:
    """Wrapper combining all 3 helpers"""
    configure_cmake()
    build(None, jobs)
    install(None)
    
def build_target(targets: list[str], jobs: int) -> None:
    """Wrapper combining all 3 helpers"""
    configure_cmake()
    build(targets, jobs)
    install(targets)

# =================================================================================================
# MAIN
# =================================================================================================


def main():
    ### Parse command line args
    parser = argparse.ArgumentParser(
        description="Sunswift build and staging tool"
    )

    common_flags = argparse.ArgumentParser(add_help=False)
    common_flags.add_argument("--jobs", "-j", default=8, type=int, help="Number of parallel jobs Make runs. Default=8")
    parser.add_argument(
        "--repo-root",
        help="Path to repository root (or set SR_REPO_ROOT). Defaults to git root.",
    )
    
    level1_junction = parser.add_subparsers(dest="command", required=True)
    command_all = level1_junction.add_parser("all", parents=[common_flags], help="Build and install all targets")
    command_clean = level1_junction.add_parser("clean", help="Delete the build directory, but NOT deploy/")
    command_target = level1_junction.add_parser("target", parents=[common_flags], help="Select specific nodes to build and install")
    command_target.add_argument("targets", nargs="+", help="One or more node target names")
    args = parser.parse_args() 

    ### SANITY CHECK - immediately fail if not used within repository
    global REPO_ROOT, BUILD_DIR_PATH, CMAKELISTS_PATH, INSTALL_PREFIX
    REPO_ROOT = resolve_repo_root(args.repo_root)
    validate_repo_root(REPO_ROOT)
    BUILD_DIR_PATH = REPO_ROOT / "build"
    CMAKELISTS_PATH = REPO_ROOT / "CMakeLists.txt"
    INSTALL_PREFIX = REPO_ROOT / "deploy"
    try:
        CWD.relative_to(REPO_ROOT)
    except ValueError:
        die("Error: Script must be run within repository")

    if args.command == "all":
        build_all(args.jobs)
    elif args.command == "target":
        build_target(args.targets, args.jobs)
    elif args.command == "clean":
        clean()

if __name__ == "__main__":
    main()
    
