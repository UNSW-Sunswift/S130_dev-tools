#!/usr/bin/env python3

###############################################################################
# Sunswift High Level DDS Package generator
# Version: V3.0
# Date: 24/12/2025
# Author: Ryan Wong
#
# Creates a new package according to this structure in the directory which you
# run this script from
#
# <package_name>/
#     .srpkg
#     src/
#     include/
#     config/
#     CMakeLists.txt
#     README.md
#     param/ (optional, only when --with-param)
#
# src -> all your .cpp files
# include -> all your .hpp files
# config -> build config for OS targets
# param -> json files (probably) for static params (optional)
#
# Usage in directory you want to create package in:
#   - srpkg create <name> [--all|--linux|--qnx] [--with-param]
# Usage from anywhere in repository
#   - srpkg info <name>
#   - srpkg list
###############################################################################

import argparse
import os
import sys
import re
import shutil
import json
import subprocess
from typing import Optional
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass

# =================================================================================================
# CONSTANTS
# =================================================================================================

CWD = Path.cwd().resolve()
REPO_ROOT = Path()
MARKER_FILE = ".sunswift-evsn"

# All of these are relative to pkg top level
NESTED_DIRS = {
    "src": "src",
    "include": "include",
    "config": "config",
}
FILES = {
    "metadata": ".srpkg",
    "make": "CMakeLists.txt",
    "readme": "README.md",
    "config": "config/config.json",
    "main": "src/main.cpp",
}
PARAM_DIR = "param"
PARAM_FILE = "param/{pkg_name}_param.json"

CLI_ARGS = {
    "create": ["name"],
    "info": ["name"],
    "list": []
}

@dataclass
class PkgPaths:
    pkg_name: str
    abs_pkg_path: Path

# =================================================================================================
# HELPERS
# =================================================================================================

def die(msg: str) -> None:
    print(msg)
    sys.exit(1)

def git_toplevel(path: Path) -> Path:
    try:
        result = subprocess.run(
            ["git", "-C", str(path), "rev-parse", "--show-toplevel"],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
    except FileNotFoundError:
        die("Error: git not found; cannot determine repository root")
    except subprocess.CalledProcessError:
        die("Error: not a git repository (or any of the parent directories)")
    root = result.stdout.strip()
    if not root:
        die("Error: git returned empty repository root")
    return Path(root).resolve()

def resolve_repo_root(cli_root: Optional[str]) -> Path:
    env_root = os.environ.get("SR_REPO_ROOT")
    if cli_root:
        candidate = Path(cli_root).expanduser().resolve()
    elif env_root:
        candidate = Path(env_root).expanduser().resolve()
    else:
        return git_toplevel(CWD)

    if not candidate.exists() or not candidate.is_dir():
        die("Error: repo root does not exist or is not a directory")
    git_root = git_toplevel(candidate)
    if git_root != candidate:
        die("Error: repo root is not a git repository root")
    return candidate

def validate_repo_root(repo_root: Path) -> None:
    if not (repo_root / "src").exists() and not (repo_root / "core").exists():
        die("Error: repository root missing src/ or core/")
    if not (repo_root / MARKER_FILE).exists():
        die(f"Error: marker file '{MARKER_FILE}' not found in repository root")

def dir_size(path: Path) -> int:
    return sum(
        p.stat().st_size
        for p in path.rglob("*")
        if p.is_file()
    )

def fill_readme(paths: PkgPaths) -> None:
    text = f"""# {paths.pkg_name} DDS Package

## Description
Briefly describe the purpose of this DDS node.

## Topics Published to
Enter topics published to below
Topic | C++ Type | Description
------|----------|------------
/domain/subsystem/topic|`C++ Type`|BMS Voltage

## Topics Subscribed to
Enter topics subscribed to below
Topic | C++ Type | Description
------|----------|------------
/domain/subsystem/topic|`C++ Type`|BMS Voltage

## Parameters
Add runtime parameters here if you created a param JSON file.

## Build Config
See `config/config.json` for the OS build flags.

## Contributors
Written by `Your name here` | `Your zID here`"""
    with (paths.abs_pkg_path / FILES["readme"]).open("w") as file:
        file.write(text)

def fill_cmakelists(paths: PkgPaths, create_param: bool) -> None:
    text = f"""# Per-node info
set(TARGET_NAME {paths.pkg_name})
set(SOURCES
    src/main.cpp
)
set(INCLUDE_DIRS
    include
)
set (LIBS
    dds_node
    # add your type libraries here
    # add other dependencies here
)

# Compile and link
add_executable(${{TARGET_NAME}} ${{SOURCES}})
target_include_directories(${{TARGET_NAME}} PRIVATE ${{INCLUDE_DIRS}})
target_link_libraries(${{TARGET_NAME}} PRIVATE ${{LIBS}})

# Install time
install(
    TARGETS ${{TARGET_NAME}}
    RUNTIME DESTINATION bin
    COMPONENT ${{TARGET_NAME}}
)"""
    if create_param:
        text += f"""
install(
    FILES param/${{TARGET_NAME}}_param.json
    DESTINATION param
    COMPONENT ${{TARGET_NAME}}
)"""
    with (paths.abs_pkg_path / FILES["make"]).open("w") as file:
        file.write(text)

def fill_config(paths: PkgPaths, build_config: dict[str, bool]) -> None:
    config_path = paths.abs_pkg_path / FILES["config"]
    with config_path.open("w") as file:
        json.dump(build_config, file, indent=2, sort_keys=True)
        file.write("\n")

def fill_param(paths: PkgPaths) -> None:
    param_path = paths.abs_pkg_path / PARAM_FILE.format(pkg_name=paths.pkg_name)
    with param_path.open("w") as json_file:
        json_file.write("{}")

def pkg_exist_elsewhere(paths: PkgPaths) -> tuple[bool, Optional[Path]]:
    """Recursively checks if valid package with the same name exists in src
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    Returns:
        tuple[bool, Optional[Path]]: (True/False, RELATIVE path of where it is/None)
    """

    src_path = REPO_ROOT / "src"
    for path in src_path.rglob(paths.pkg_name):
        if path.is_dir() and (path/FILES["metadata"]).exists():
            return (True, path.relative_to(REPO_ROOT))

    return (False, None)

def safe_rmdir(paths: PkgPaths) -> None:
    """Absolutely every error check again just to confirm before deletion.
    In case any bugs in error checking happen before. Then deletes
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    """
    if not paths.abs_pkg_path.exists():
        die("Delete: Path does not exist")

    if not paths.abs_pkg_path.is_dir():
        die("Delete: Path is not a directory")

    if not (paths.abs_pkg_path/FILES["metadata"]).exists():
        die("Delete: Path is not a Sunswift Package")

    if paths.abs_pkg_path.is_symlink():
        die("Delete: Path is a symlink")

    try:
        # Check if path is within repository
        paths.abs_pkg_path.relative_to(REPO_ROOT)
    except ValueError:
        die("Path not within SRP8-130_EMBD_High_Level repository")

    if (paths.abs_pkg_path == REPO_ROOT or
        paths.abs_pkg_path == "/" or
        paths.abs_pkg_path == REPO_ROOT / "src"):
        die("wtf are u doing man")

    shutil.rmtree(paths.abs_pkg_path)

def validate_name(name: str) -> PkgPaths:
    ### Validate node package name
    pattern = r"^[a-z0-9_]*$"
    if not re.match(pattern, name):
        die("Invalid package name: must be in 'snake_case'")

    # Make paths objects
    abs_pkg_path = CWD / name
    paths = PkgPaths(name, abs_pkg_path)
    return paths

# =================================================================================================
# CORE LOGIC
# =================================================================================================

def parse_args() ->argparse.Namespace:
    """
    Constructs a 1 level parser with all arguments specified in CLI_ARGS above,
    then executes and returns args

    You can use args.command (first level), then args.name for leaf arg
    """
    ### Command line arguments
    root_parser = argparse.ArgumentParser(
        description=f"Sunswift DDS package management tool. \
        Packages are created in your current working directory."
    )
    root_parser.add_argument(
        "--repo-root",
        help="Path to repository root (or set SR_REPO_ROOT). Defaults to git root.",
    )
    # at a junction, there can be many options, where one option can be another junction
    # imagine a tree structure
    level1_junction = root_parser.add_subparsers(dest="command", required=True)
    for command, arg_array in CLI_ARGS.items():
        level1_option = level1_junction.add_parser(command)
        for arg in arg_array:
            level1_option.add_argument(arg)
        if command == "create":
            build_group = level1_option.add_mutually_exclusive_group()
            build_group.add_argument(
                "--all",
                action="store_true",
                help="Enable linux and qnx builds",
            )
            build_group.add_argument(
                "--linux",
                action="store_true",
                help="Enable linux build only",
            )
            build_group.add_argument(
                "--qnx",
                action="store_true",
                help="Enable qnx build only",
            )
            level1_option.add_argument(
                "--with-param",
                action="store_true",
                help="Create an optional param JSON file",
            )

    return root_parser.parse_args()

def mkdir_package(paths: PkgPaths, create_param: bool) -> tuple[list[str], list[str]]:
    """Actually makes the directory structure"""
    created_dirs = []
    created_files = []
    paths.abs_pkg_path.mkdir()
    for dir in NESTED_DIRS.values():
        (paths.abs_pkg_path / dir).mkdir()
        created_dirs.append(dir)
    if create_param:
        (paths.abs_pkg_path / PARAM_DIR).mkdir()
        created_dirs.append(PARAM_DIR)

    for file in FILES.values():
        new_file = file.format(pkg_name=paths.pkg_name)
        (paths.abs_pkg_path / new_file).touch()
        created_files.append(new_file)
    if create_param:
        param_file = PARAM_FILE.format(pkg_name=paths.pkg_name)
        (paths.abs_pkg_path / param_file).touch()
        created_files.append(param_file)

    return created_dirs, created_files

def pkg_create(paths: PkgPaths, build_config: dict[str, bool], create_param: bool) -> None:
    """Creates directory based on structure in top comment if it doesn't already exist.
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    """
    # Must be created in src/
    try:
        CWD.relative_to(REPO_ROOT/"src")
    except ValueError:
        die("Error: Packages should be created only in src/")

    # Check if something with same name already exists in CWD
    if paths.abs_pkg_path.exists():
        die(f"Error: {paths.pkg_name} already exists at '{paths.abs_pkg_path.relative_to(REPO_ROOT)}'")

    # Check if pkg exists elsehwhere in src/ (if not in cwd)
    res, location = pkg_exist_elsewhere(paths)
    if res:
        die(f"Error: {paths.pkg_name} already exists at '{location}'")

    # Create directories and files
    try:
        created_dirs, created_files = mkdir_package(paths, create_param)
        fill_readme(paths)
        fill_cmakelists(paths, create_param)
        fill_config(paths, build_config)
        if create_param:
            fill_param(paths)
    except Exception as e:
        if paths.abs_pkg_path.exists():
            safe_rmdir(paths)
        die(f"Error creating package: {e}")

    print(f"Package '{paths.pkg_name}' created successfully!")
    print(f"Location: {paths.abs_pkg_path.relative_to(REPO_ROOT)}\n")

    print("Created structure:")
    # Directories
    for dir in created_dirs:
        print(f"  {dir}")
    # Files
    for file_name in created_files:
        print(f"  {file_name}")

def pkg_info(paths: PkgPaths) -> None:
    """ Finds package with given name in repository
    Args:
        paths (PkgPaths): _description_
    """
    res, location = pkg_exist_elsewhere(paths)

    if not res or location is None:
        die(f"Package: '{paths.pkg_name}' not found in src/")
        return # pydantic shut up

    print(f"=============== {paths.pkg_name} INFO ===============")
    # get size and num things
    abs_path = REPO_ROOT / location
    size_bytes = dir_size(abs_path)
    size_kb = size_bytes / 1024
    num_files = sum(1 for thing in abs_path.rglob("*") if thing.is_file())
    num_dirs = sum(1 for thing in abs_path.rglob("*") if thing.is_dir())

    # Get last modified + creation times
    all_files = list(abs_path.rglob("*"))
    if all_files:
        creation_ts = min(p.stat().st_ctime for p in all_files)
        last_mod_ts = max(p.stat().st_mtime for p in all_files)
    else:
        creation_ts = last_mod_ts = abs_path.stat().st_ctime

    creation_date = datetime.fromtimestamp(creation_ts).strftime("%d/%m/%Y %H:%M:%S")
    last_mod_date = datetime.fromtimestamp(last_mod_ts).strftime("%d/%m/%Y %H:%M:%S")

    # Combine all names to compute max padding
    all_names = list(NESTED_DIRS.values()) + list(FILES.values())
    max_len = max(len(name) for name in all_names) + 2

    print(f"Package: '{paths.pkg_name}'")
    print(f"Location: {location}")
    print(f"Total size: {size_bytes} B ({size_kb:.2f} KB)")
    print(f"Contents: {num_dirs} directories, {num_files} files")
    print(f"Created: {creation_date}")
    print(f"Last modified: {last_mod_date}")

    # List source files
    src_dir = abs_path / "src"
    if src_dir.exists():
        cpp_files = sorted([f.relative_to(abs_path) for f in src_dir.rglob("*.cpp")])
        if cpp_files:
            print("\nSource files (.cpp):")
            for f in cpp_files:
                print(f"  {f}")

    # List header files
    include_dir = abs_path / "include"
    if include_dir.exists():
        hpp_files = sorted([f.relative_to(abs_path) for f in include_dir.rglob("*.hpp")])
        if hpp_files:
            print("\nHeader files (.hpp):")
            for f in hpp_files:
                print(f"  {f}")

def pkg_list() -> None:
    """Lists all valid DDS packages under src/. Valid means contains FILES["metadata"]"""
    src_root = REPO_ROOT / "src"
    if not src_root.exists():
        die("No src/ directory found in repository.")

    print(f"=============== NODE LIST ===============")
    packages = []

    # recursively search
    for path in src_root.rglob("*"):
        if path.is_dir() and (path / FILES["metadata"]).exists():
            pkg_name = path.name
            rel_path = path.relative_to(REPO_ROOT)
            packages.append((pkg_name, rel_path))

    if not packages:
        print("No packages found in src/")
        return

    # sort by name for neatness (already sorts using first tuple element)
    # packages.sort()

    # Determine padding for alignment
    max_name_len = max(len(name) for name, _ in packages) + 2

    print(f"Found {len(packages)} package(s) in src/:\n")
    for name, rel_path in packages:
        print(f"  {name.ljust(max_name_len)} : {rel_path}")


# =================================================================================================
# MAIN
# =================================================================================================
def main():
    args = parse_args()

    ### SANITY CHECK:
    # Check that script is run in repo
    global REPO_ROOT
    REPO_ROOT = resolve_repo_root(args.repo_root)
    validate_repo_root(REPO_ROOT)
    try:
        CWD.relative_to(REPO_ROOT)
    except ValueError:
        die("Error: Script must be run within repository")

    ### LOGIC BASED ON FLAGS
    cmd = args.command
    if cmd == "create":
        paths = validate_name(args.name)
        build_config = {"linux": True, "qnx": False}
        if args.all:
            build_config = {"linux": True, "qnx": True}
        elif args.qnx:
            build_config = {"linux": False, "qnx": True}
        elif args.linux:
            build_config = {"linux": True, "qnx": False}
        pkg_create(paths, build_config, args.with_param)
    elif cmd == "info":
        paths = validate_name(args.name)
        pkg_info(paths)
    elif cmd == "list":
        pkg_list()


if __name__ == "__main__":
    main()
